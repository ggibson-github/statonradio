<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stanton Radio — Star Citizen Spacewave</title>
  <meta name="description" content="A sci‑fi themed, animated space radio station that plays randomized video playlists from JSON files on a GitHub Pages static site." />
  <style>
    /*
      ──────────────────────────────────────────────────────────────────────
      STANTON RADIO — SINGLE‑FILE STATIC SITE
      Theme: Deep space (stars, gas clouds, planets) + drifting ships + GIF zooms
      Hosting: GitHub Pages (no server code).

      FILE LAYOUT you should create in your repo:
      /
      ├─ index.html                          ← this file
      ├─ /media/                             ← place all provided assets here
      │   ├─ sc_video_1.gif … sc_video_10.gif
      │   ├─ star‑citizen‑*.png, combat_spaceship_*.png, distant_spacestation_*.png …
      └─ /playlists/
          ├─ index.json                      ← manifest that lists your playlists
          ├─ ambient.json                    ← example playlist (see template below)
          └─ combat.json

      playlists/index.json (example):
      {
        "playlists": ["ambient.json", "combat.json"]
      }

      playlists/ambient.json (example):
      {
        "title": "Ambient Drift",
        "items": [
          {
            "title": "Chill Loop — Nebulae",
            "url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            "link": "https://creator.example.com/nebulae"   // optional: external link for creator/title in UI
          },
          {
            "title": "Rumble Sample",
            "url": "https://rumble.com/v3vabcd-sample-track.html",
            "durationSec": "4:00", // optional fallback if end cannot be detected; supports "mm:ss" or "h:mm:ss"
            "link": "https://rumble.com/c/CreatorChannel"    // optional external link displayed in UI
          }
        ]
      }

      NOTE on embeds: YouTube is fully supported via the IFrame API (auto‑advance on end).
      Rumble supports two modes:
      1) **Embed mode** (default): https://rumble.com/embed/<VIDEOID>/?autoplay=2
      2) **Creator page mode**: pass a regular watch URL (e.g. https://rumble.com/v6wxhx6-....html?mref=...&mc=...) and set `"display": "page"` for that item in your playlist to attempt loading the full page in the player. If the browser blocks framing that page, the site automatically falls back to the embed URL. You can globally prefer page mode by toggling `PREFER_RUMBLE_PAGE` inside the script.
      We also honor optional "durationSec" to auto‑advance if an "ended" signal can't be detected.
      ──────────────────────────────────────────────────────────────────────
    */

    :root{
      --bg:#05060a;           /* deep space */
      --star:#9fb3ff;         /* cool starlight */
      --accent:#52ffe3;       /* neon cyan */
      --accent2:#8f7dff;      /* violet glow */
      --glass: rgba(255,255,255,0.08);
      --glassBorder: rgba(255,255,255,0.18);
      --text:#e6f0ff;
      --muted:#9aa7c7;
      /* total non-video vertical chrome inside the card (header + controls + borders) */
      --cardChrome: 160px;
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Inter,"Helvetica Neue",Arial,sans-serif}
    html{overflow:hidden}
    body{overflow:hidden}

    /* Space sky layers */
    #sky{position:fixed;inset:0;overflow:hidden;z-index:0;pointer-events:none}

    /* Twinkling stars using multiple background layers */
    .stars{position:absolute;inset:0;
      background:
        radial-gradient(ellipse at 20% 30%, rgba(79,95,160,0.18), transparent 60%),
        radial-gradient(ellipse at 80% 70%, rgba(113,83,171,0.14), transparent 60%),
        radial-gradient(ellipse at 60% 15%, rgba(255,255,255,0.05), transparent 40%),
        #05060a;
      /* removed mask to avoid hiding corners/top-left */
    }

    /* Procedural tiny stars via pseudo element */
    .stars::before, .stars::after{
      content:"";position:absolute;inset:-50%;
      background-image:
        radial-gradient(2px 2px at 20% 30%, var(--star) 48%, transparent 52%),
        radial-gradient(1.5px 1.5px at 55% 60%, rgba(255,255,255,.9) 50%, transparent 51%),
        radial-gradient(1.5px 1.5px at 85% 25%, rgba(255,255,255,.8) 50%, transparent 51%),
        radial-gradient(1px 1px at 35% 80%, rgba(255,255,255,.8) 50%, transparent 51%),
        radial-gradient(1px 1px at 75% 45%, rgba(255,255,255,.9) 50%, transparent 51%);
      animation: driftStars 160s linear infinite;
      opacity:.75
    }
    .stars::after{animation-duration: 220s;opacity:.5;filter:blur(.3px)}
    @keyframes driftStars{from{transform:translate3d(0,0,0)}to{transform:translate3d(10%,10%,0)}}

    /* Background GIF stage (crossfading zooms) */
    .gif-stage{position:absolute;inset:0;overflow:hidden;pointer-events:none}
    .bg-gif{position:absolute;inset:-5%;object-fit:cover;width:110%;height:110%;opacity:0;transition:opacity 1200ms ease}
    .bg-gif.visible{opacity:.23;animation: kenburns 12s ease-in-out infinite}
    @keyframes kenburns{0%{transform:scale(1) translateZ(0)}50%{transform:scale(1.06) translateZ(0)}100%{transform:scale(1) translateZ(0)}}

    /* Drifting ship sprites */
    #spriteLayer{position:absolute;inset:0;pointer-events:none}
    .sprite{position:absolute;will-change:transform,opacity;opacity:.9;filter:drop-shadow(0 10px 20px rgba(0,0,0,.6))}
    .sprite.flip{transform:scaleX(-1)}

    /* Center stage */
    main{position:relative;z-index:1;display:grid;place-items:center;height:100dvh;height:100svh;overflow:hidden;padding:4vmin}

    .card{width:min(980px, 90vw, calc((100svh - 8vmin - var(--cardChrome)) * 16 / 9));max-height:calc(100svh - 8vmin);display:flex;flex-direction:column;min-height:0;backdrop-filter: blur(8px);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--glassBorder);border-radius:24px;box-shadow:0 30px 50px rgba(0,0,0,.5);
      overflow:hidden
    }

    /* Docked variants: tall, thin, pinned to screen edge */
    .card.docked{position:fixed;top:0;bottom:0;height:100svh;max-height:100svh;border-radius:0;z-index:2}
    .card.dock-right{right:0;left:auto;width:clamp(280px, 28vw, 420px)}
    .card.dock-left{left:0;right:auto;width:clamp(280px, 28vw, 420px)}

    /* Tighter player layout in docked mode: portrait video area */
    /* In docked mode, let the player flex to the remaining height to avoid clipping */
    .card.docked .player{flex:1 1 auto; min-height:0}
    .card.docked .player-container{position:relative; width:100%; height:100%; max-height:100%; aspect-ratio:auto}
    .card.docked .controls{gap:8px;padding:12px 14px}
    .card.docked .control-group{gap:6px}
    .card.docked .controls button{font-size:.8em;padding:8px 11px;border-radius:10px}
    .card.docked .status{font-size:11px}
    .card.docked .title-row h1{font-size:clamp(18px, 3vw, 26px)}
    .card.docked .nowplaying{font-size:12px}

    .card-header{padding:14px 22px 6px;border-bottom:1px solid var(--glassBorder);
      background:linear-gradient(180deg,rgba(82,255,227,.10),transparent 70%)}
    .title-row{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
    h1{font-size:clamp(22px, 3.2vw, 34px);margin:0;letter-spacing:.5px;line-height:1.05}
    .badge{font-size:12px;padding:4px 10px;border-radius:999px;border:1px solid var(--glassBorder);background:var(--glass);color:var(--accent)}

    .nowplaying{font-size:14px;color:var(--muted);margin-top:6px}
    .nowplaying-link{color:var(--muted);text-decoration:none}
    .nowplaying-link:hover{color:var(--text);text-decoration:underline}

    /* Optional creator logo next to now playing text */
    .creator-logo{display:none;height:18px;width:auto;vertical-align:text-bottom;margin-right:8px;border-radius:4px;opacity:0;transition:opacity 150ms ease}
    /* When enabled, blends white areas into the backdrop (approximate knockout on dark UI) */
    .creator-logo.knock-white{mix-blend-mode:multiply}

    /* Neon wireless signal next to Live Mix */
    .neon-signal{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;color:var(--accent);
      filter: drop-shadow(0 0 4px rgba(82,255,227,.45)) drop-shadow(0 0 10px rgba(82,255,227,.30));}
    .neon-signal svg{display:block}
    .neon-signal .arc{stroke:currentColor;stroke-width:1.8;fill:none;stroke-linecap:round;opacity:.5}
    .neon-signal .dot{fill:currentColor;opacity:.9;filter: drop-shadow(0 0 6px rgba(82,255,227,.8))}
    @keyframes neonPulse{0%{opacity:.25}50%{opacity:1}100%{opacity:.25}}
    .neon-signal .arc1{animation:neonPulse 1.8s ease-in-out infinite}
    .neon-signal .arc2{animation:neonPulse 1.8s ease-in-out -.45s infinite}
    .neon-signal .arc3{animation:neonPulse 1.8s ease-in-out -.9s infinite}

    .player{position:relative;display:flex;justify-content:center;align-items:center;min-height:0;background:rgba(0,0,0,.45);border-top:1px solid rgba(255,255,255,.05);flex:1 1 auto}
    .player-container{position:relative;aspect-ratio:16/9;height:100%;width:100%;max-height:100%;}
    .player-container iframe, .player-container .yt-placeholder{position:absolute;inset:0;width:100%;height:100%;border:0;border-radius:0}

    .controls{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:12px 16px;border-top:1px solid var(--glassBorder);background:linear-gradient(180deg,transparent,rgba(255,255,255,.03))}
    .control-group{display:flex;gap:8px;align-items:center}
    button{appearance:none;border:1px solid var(--glassBorder);background:var(--glass);color:var(--text);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    button:hover{border-color:var(--accent);box-shadow:0 0 0 2px rgba(82,255,227,.15) inset}
    .status{font-size:12px;color:var(--muted)}

    /* Floating translucent dock button (when not placed in header flow) */
    .dock-toggle{backdrop-filter:saturate(120%) blur(6px)}

    /* Make the header's dock/expand button about half as tall */
    .dock-toggle{padding:5px 12px; line-height:1; font-size:.9em; border-radius:10px}

    /* Spend the saved space on extra room for bottom controls */
    .controls{padding:16px 20px}

    /* Tap to start overlay (to satisfy autoplay policies) */
    #gestureGate{position:fixed;inset:0;display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 40%, rgba(28,35,58,.65), rgba(5,6,10,.96));
      z-index:50}
    .gate-inner{display:grid;gap:16px;place-items:center;text-align:center;max-width:720px;padding:24px}
    .gate-logo{font-size:56px;line-height:0}
    .gate-title{font-size:clamp(22px, 3.4vw, 40px);margin:0}
    .gate-sub{opacity:.8}
    .start-btn{font-size:18px;padding:14px 20px;border-radius:14px;background:linear-gradient(90deg, var(--accent), var(--accent2));border:none;color:#0a0a0a;font-weight:900;cursor:pointer}

    /* Small helper tooltip style */
    .hint{font-size:12px;color:var(--muted)}

    /* Responsive niceties */
    @media (max-width:520px){
      .controls{flex-wrap:wrap}
      .status{width:100%;text-align:center;margin-top:6px}
    }
  </style>
</head>
<body>
  <!-- BACKGROUND SKY -->
  <div id="sky" aria-hidden="true">
    <div class="stars"></div>
    <div class="gif-stage">
      <img id="gifA" class="bg-gif" alt="Animated nebula background A" />
      <img id="gifB" class="bg-gif" alt="Animated nebula background B" />
    </div>
    <div id="spriteLayer"></div>
  </div>

  <!-- TAP TO START (satisfy autoplay policies) -->
  <div id="gestureGate">
    <div class="gate-inner">
      <div class="gate-logo">🛰️</div>
      <h2 class="gate-title">Stanton Radio</h2>
      <p class="gate-sub">Spacewave from the <em>Star Citizen</em> ‘verse. Animated deep‑space visuals + randomized video playlists. Tap to launch.</p>
      <button id="startBtn" class="start-btn">Launch Station</button>
      <div class="hint">Autoplay requires a user gesture in most browsers.</div>
    </div>
  </div>

  <!-- MAIN CARD -->
  <main>
    <section class="card" aria-live="polite">
      <header class="card-header">
        <div class="title-row">
          <h1>Stanton Radio</h1>
          <span class="badge">Live Mix</span>
          <span class="neon-signal" aria-hidden="true" title="On‑air">
            <svg width="22" height="22" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <circle class="dot" cx="12" cy="12" r="1.6" />
              <path class="arc arc1" d="M8.5 12 C 9.8 9.5, 14.2 9.5, 15.5 12" />
              <path class="arc arc2" d="M6 12 C 8 7, 16 7, 18 12" />
              <path class="arc arc3" d="M3 12 C 6 4.5, 18 4.5, 21 12" />
            </svg>
          </span>
          <button id="dockBtn" class="dock-toggle" style="margin-left:auto" title="Dock: click to dock right, Shift+click to dock left">⇲ Dock</button>
        </div>
        <div class="nowplaying">
          <a id="nowPlayingLink" href="#" target="_blank" rel="noopener" class="nowplaying-link" aria-label="Open creator link in new tab">
            <img id="creatorLogo" class="creator-logo" alt="" />
            <span id="playlistName">—</span>
            <span> • </span>
            <span id="trackTitle">Ready</span>
          </a>
        </div>
      </header>

      <div class="player">
        <div id="playerContainer" class="player-container" aria-label="Video player"></div>
      </div>

      <div class="controls">
        <div class="control-group">
          <button id="prevBtn" title="Previous">⏮ Prev</button>
          <button id="nextBtn" title="Next">⏭ Next</button>
          <button id="shuffleBtn" title="Reshuffle playlist">🔀 Shuffle</button>
        </div>
        <div class="control-group">
          <button id="reloadBtn" title="Pick a new random playlist">🎲 New Playlist</button>
          <button id="downloadBtn" title="Download current playlist JSON">⬇️ List</button>
        </div>
        <div id="status" class="status">Loading playlists…</div>
      </div>
    </section>
  </main>

  <!-- YouTube IFrame API for reliable end‑of‑video detection -->
  <script async src="https://www.youtube.com/iframe_api"></script>

  <script>
    // ─────────────────────────────────────────────────────────────────────
    // CONFIG — update paths to match your repo structure
    // ─────────────────────────────────────────────────────────────────────
    const MEDIA_PATH = './media/';
    const DEBUG = true;
    const log = (...args) => { try{ if(DEBUG) console.log('[SR]', ...args); }catch(_){} };
    const warn = (...args) => { try{ if(DEBUG) console.warn('[SR]', ...args); }catch(_){} };
    const PLAYLISTS_MANIFEST_URL = './playlists/index.json';
    // Prefer simple iframe embeds for Rumble by default
    const USE_RUMBLE_JS = false;

    // Provided content (place these exact files in /media/)
    const GIFS = [
      './media/bg/set_2_sc_video_10.gif',
      './media/bg/set_1_sc_video_5.gif',
      './media/bg/set_5_sc_video_8.gif',
      './media/bg/set_3_sc_video_10.gif',
      './media/bg/set_3_sc_video_8.gif',
      './media/bg/set_3_sc_video_4.gif',
      './media/bg/set_2_sc_video_9.gif',
      './media/bg/set_6_sc_video_9.gif',
      './media/bg/set_5_sc_video_6.gif',
      './media/bg/set_5_sc_video_4.gif',
      './media/bg/set_4_sc_video_8.gif',
      './media/bg/set_4_sc_video_6.gif',
      './media/bg/set_6_sc_video_4.gif',
      './media/bg/set_4_sc_video_9.gif',
      './media/bg/set_4_sc_video_4.gif',
      './media/bg/set_4_sc_video_2.gif',
      './media/bg/set_6_sc_video_8.gif',
      './media/bg/set_6_sc_video_1.gif',
      './media/bg/set_5_sc_video_3.gif',
      './media/bg/set_3_sc_video_9.gif',
      './media/bg/set_3_sc_video_5.gif',
      './media/bg/set_2_sc_video_3.gif',
      './media/bg/set_2_sc_video_6.gif',
      './media/bg/set_4_sc_video_7.gif',
      './media/bg/set_6_sc_video_3.gif',
      './media/bg/set_5_sc_video_2.gif',
      './media/bg/set_3_sc_video_3.gif',
      './media/bg/set_2_sc_video_8.gif',
      './media/bg/set_6_sc_video_7.gif',
      './media/bg/set_5_sc_video_10.gif',
      './media/bg/set_2_sc_video_7.gif',
      './media/bg/set_1_sc_video_4.gif',
      './media/bg/set_1_sc_video_2.gif',
      './media/bg/set_5_sc_video_5.gif',
      './media/bg/set_5_sc_video_1.gif',
      './media/bg/set_2_sc_video_5.gif',
      './media/bg/set_2_sc_video_2.gif',
      './media/bg/set_1_sc_video_6.gif',
      './media/bg/set_6_sc_video_10.gif',
      './media/bg/set_6_sc_video_2.gif',
      './media/bg/set_4_sc_video_5.gif',
      './media/bg/set_4_sc_video_1.gif',
      './media/bg/set_3_sc_video_7.gif',
      './media/bg/set_2_sc_video_4.gif',
      './media/bg/set_2_sc_video_1.gif',
      './media/bg/set_6_sc_video_6.gif',
      './media/bg/set_5_sc_video_9.gif',
      './media/bg/set_3_sc_video_2.gif',
      './media/bg/set_1_sc_video_9.gif',
      './media/bg/set_1_sc_video_8.gif',
      './media/bg/set_1_sc_video_1.gif',
      './media/bg/set_6_sc_video_5.gif',
      './media/bg/set_5_sc_video_7.gif',
      './media/bg/set_4_sc_video_10.gif',
      './media/bg/set_3_sc_video_1.gif',
      './media/bg/set_1_sc_video_10.gif',
      './media/bg/set_1_sc_video_7.gif',
      './media/bg/set_1_sc_video_3.gif',
      './media/bg/set_4_sc_video_3.gif',
      './media/bg/set_3_sc_video_6.gif'
    ];

    const SHIPS = [
      'star-citizen-wing-commander-vehicle-industry-spacecraft-star_1167x681_RL.png',
      'combat_spaceship_3081x1321_RL.png',
      'distant_spacestation_640x423.png',
      'hornet-star-citizen-spacecraft-anvil-tool_1268x390_RL.png',
      'ship-aegis-star-citizen-frigate-f-t-w-w-w-star_3449x2110_LR.png',
      'ship-sky-vehicle-star-citizen-italy-star_2500x1337_RL.png',
      'spacecraft-interplanetary-spaceflight-star-citizen-information-interstellar-medium-star_1134x450_LR.png',
      'star-citizen-cargo-ship-cloud-imperium-games-transport_1181x508_LR.png',
      'star-citizen-centauri-alliance-game_1200x800_RL.png',
      'star-citizen-cloud-imperium-games-aurora-ign_709x372_RL.png',
      'star-citizen-cloud-imperium-games-gamescom-constellation-star_709x385_RL.png',
      'star-citizen-cloud-imperium-games-youtube_1502x753_RL.png',
      'star-citizen-corvette-ship-civilian-navy-star_9000x2527_LR.png',
      'star-citizen-gamescom-ship-youtube-space-cargo_2373x674_LR.png',
      'star-citizen-hawk-hildesheim-holzminden-goettingen-cloud-imperium-games-ship-reddit-star_1210x731.png',
      'star-citizen-polaris-industries-cloud-imperium-games-ship-side-by-side_1401x856_RL.png',
      'star-citizen-spacecraft-cloud-imperium-games_773x345_LR.png',
      'star-citizen-spacecraft-starship-battlestar-star_1024x906_LR.png',
      'star-citizen-transport-hangar-vehicle-ship-star_1920x1080.png',
      'star-citizen-tropical-cyclone-forecast-model-cloud-imperium-games-spacecraft-star_2629x1286_LR.png'
    ].map(n => MEDIA_PATH + n);

    // Fallback playlists (used only if fetching /playlists/* fails)
    const INLINED_PLAYLISTS = [
      {
        id:'ambient', title:'Ambient Drift (Inlined)', items:[
          {title:'Chill Loop — Nebulae', url:'https://www.youtube.com/watch?v=dQw4w9WgXcQ', link:'https://creator.example.com/nebulae'},
          {title:'Rumble Creator Page Demo', url:'https://rumble.com/v6wxhx6--stanton-radio-part-1.html?mref=3rqnmr&mc=b4zy1', display:'page', durationSec:240, link:'https://rumble.com/c/StantonRadio'}
        ]
      }
    ];

    // ─────────────────────────────────────────────────────────────────────
    // UTILITIES
    // ─────────────────────────────────────────────────────────────────────
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    // Parse duration values to seconds. Accepts number, numeric string, or
    // timecode strings like "m:ss" or "h:mm:ss". Applies defaults + minimums.
    function parseDurationToSec(val, defaultSec, minSec){
      const min = Number.isFinite(minSec) ? minSec : 0;
      const def = Number.isFinite(defaultSec) ? defaultSec : 0;
      if(val == null) return def;
      if(typeof val === 'number' && isFinite(val)) return Math.max(min, val);
      if(typeof val === 'string'){
        const s = val.trim();
        if(/^[0-9]+$/.test(s)) return Math.max(min, parseInt(s,10));
        if(s.includes(':')){
          const parts = s.split(':').map(t=>t.trim());
          let total = 0;
          if(parts.length === 2){
            const m = parseInt(parts[0],10); const sec = parseInt(parts[1],10);
            if(!isNaN(m) && !isNaN(sec)) total = m*60 + sec;
          } else if(parts.length === 3){
            const h = parseInt(parts[0],10); const m = parseInt(parts[1],10); const sec = parseInt(parts[2],10);
            if(!isNaN(h) && !isNaN(m) && !isNaN(sec)) total = h*3600 + m*60 + sec;
          }
          if(total > 0) return Math.max(min, total);
        }
      }
      return def;
    }

    function shuffle(a){
      for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}
      return a
    }

    function pick(arr){return arr[Math.floor(Math.random()*arr.length)]}

    // Convert YouTube or Rumble URLs to embeddable/page forms
    // Supports optional per-item flag: item.display === "page" to try loading full Rumble page
    const PREFER_RUMBLE_PAGE = false; // set true to prefer creator page when possible
    function toEmbed(item){
      const url = typeof item === 'string' ? item : (item && item.url);
      try{
        const u = new URL(url);
        const host = u.hostname.replace('www.','');

        // YouTube: supports watch, youtu.be, and already-embedded forms
        if(host.includes('youtube.com') || host === 'youtu.be'){
          let id = null;
          if(host === 'youtu.be'){
            id = u.pathname.replace('/','');
          } else if(u.pathname.startsWith('/embed/')){
            id = u.pathname.split('/').pop();
          } else {
            id = u.searchParams.get('v');
          }
          if(!id) throw new Error('No YouTube video id');
          return {
            provider:'youtube',
            embed:`https://www.youtube.com/embed/${id}?autoplay=1&rel=0&modestbranding=1&enablejsapi=1&playsinline=1`
          };
        }

        // Rumble: supports already-embedded URLs and regular watch URLs
        if(host.includes('rumble.com')){
          // If this is already an /embed/ URL, preserve query (add autoplay=2 if missing)
          if(u.pathname.startsWith('/embed/')){
            const qs = new URLSearchParams(u.search);
            if(!qs.has('autoplay')) qs.set('autoplay','2');
            // Extract id from /embed/<VID>/ optionally with trailing slash
            const segs = u.pathname.split('/').filter(Boolean);
            const vid = segs.length >= 2 ? segs[1] : null;
            const info = { provider:'rumble', embed:`${u.origin}${u.pathname}?${qs.toString()}`, id: vid };
            log('toEmbed: Rumble embed URL detected', info);
            return info;
          }

          // Regular watch link (creator page). Extract ID (vXXXX...)
          const segs = u.pathname.split('/').filter(Boolean);
          const last = segs[segs.length-1] || '';
          const m = last.match(/(v[0-9A-Za-z_]+)/);
          if(m){
            const id = m[1];
            const qs = new URLSearchParams(u.search);
            if(!qs.has('autoplay')) qs.set('autoplay','2');
            const embedUrl = `https://rumble.com/embed/${id}/?${qs.toString()}`;

            const wantPage = (item && item.display === 'page') || PREFER_RUMBLE_PAGE;
            if(wantPage){
              const info = { provider:'rumblePage', page:u.toString(), fallbackEmbed:embedUrl, id };
              log('toEmbed: Rumble page mode preferred', info);
              return info;
            }
            const info = { provider:'rumble', embed: embedUrl, id };
            log('toEmbed: Rumble watch URL converted to embed', info);
            return info;
          }
          throw new Error('Unrecognized Rumble URL');
        }
      }catch(e){ /* fall through to unknown */ }
      warn('toEmbed: unknown provider', url);
      return { provider:'unknown', embed:url };
    }

    // ─────────────────────────────────────────────────────────────────────
    // BACKGROUND GIF LOOP + SHIP SPRITES
    // ─────────────────────────────────────────────────────────────────────
    const gifA = $('#gifA');
    const gifB = $('#gifB');
    let gifIndex = Math.floor(Math.random()*GIFS.length);
    let gifToggle = false;

    function cycleGifs(){
      const next = GIFS[gifIndex % GIFS.length];
      const el = gifToggle ? gifA : gifB;
      const off = gifToggle ? gifB : gifA;
      el.src = next;
      el.classList.add('visible');
      off.classList.remove('visible');
      gifToggle = !gifToggle;
      gifIndex++;
    }

    // Rotate every ~6s to give time for the 3s loops to breathe and crossfade
    function startGifLoop(){
      // seed both layers
      gifA.src = pick(GIFS);
      gifB.src = pick(GIFS);
      gifA.classList.add('visible');
      setInterval(cycleGifs, 6000);
    }

    const spriteLayer = document.getElementById('spriteLayer');
    const MAX_SPRITES = 2; // limit concurrent drifting ships

    function spawnSprite(){
      // Respect concurrent sprite limit
      if(spriteLayer.querySelectorAll('.sprite').length >= MAX_SPRITES){
        return;
      }
      const img = document.createElement('img');
      const chosen = pick(SHIPS);
      img.src = chosen;
      img.className = 'sprite';
      // Orientation from filename suffix: _LR.png or _RL.png
      const m = chosen.match(/_(LR|RL)\.png$/i);
      const orientation = m ? m[1].toUpperCase() : (Math.random() < 0.5 ? 'LR' : 'RL');
      const fromLeft = orientation === 'LR';
      const startX = fromLeft ? '-25vw' : '125vw';
      const endX   = fromLeft ? '125vw' : '-25vw';

      const topVh = Math.random()*80 + 5; // 5–85vh
      const scale = Math.random()*0.6 + 0.4; // 0.4–1.0
      const rot = (Math.random()*8 - 4) * (fromLeft?1:-1); // slight banking
      const dur = Math.random()*25 + 22; // 22–47s

      img.style.top = topVh + 'vh';
      img.style.left = startX;
      img.style.width = (Math.random()*22 + 12) + 'vw';

      const keyframes = [
        { transform:`translateX(0) scale(${scale}) rotate(${rot}deg)`, opacity:0 },
        { transform:`translateX(calc(${endX} - ${startX})) scale(${scale}) rotate(${rot}deg)`, opacity:1 }
      ];
      const anim = img.animate(keyframes, { duration: dur*1000, easing:'linear' });
      anim.onfinish = () => img.remove();
      spriteLayer.appendChild(img);
    }

    function startSprites(){
      // Seed up to MAX_SPRITES immediately
      for(let i=0;i<MAX_SPRITES;i++) setTimeout(spawnSprite, i*1200);
      // Periodically attempt to spawn if under the cap
      setInterval(() => { spawnSprite(); }, 7000);
    }

    // Dynamically load an external script and resolve when it loads
    function loadExternalScript(src){
      return new Promise((resolve, reject) => {
        try{
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error('Script load failed: '+src));
          document.head.appendChild(s);
        }catch(err){ reject(err); }
      });
    }

    // ─────────────────────────────────────────────────────────────────────
    // PLAYLIST LOADING & RANDOM CYCLING
    // ─────────────────────────────────────────────────────────────────────
    const state = {
      manifest: null,
      playlists: [],
      currentPlaylist: null,
      queue: [],
      index: -1,
      ytPlayer: null,
      rumbleTimer: null,
      rumblePoll: null,
      rumbleReadyTimeout: null,
      rumbleVideoObserver: null,
      rumbleVideoEl: null,
      rumbleNudge: null,
      started: false
    };

    async function loadManifest(){
      try{
        const res = await fetch(PLAYLISTS_MANIFEST_URL, {cache:'no-store'});
        if(!res.ok) throw new Error('manifest fetch failed');
        const data = await res.json();
        if(!Array.isArray(data.playlists)) throw new Error('invalid manifest');
        state.manifest = data;
        return data.playlists;
      }catch(err){
        console.warn('Manifest load failed, using inlined playlists', err);
        state.playlists = INLINED_PLAYLISTS.slice();
        return [];
      }
    }

    async function loadPlaylist(filename){
      if(!filename){
        // From inlined fallback
        const pl = pick(state.playlists);
        state.currentPlaylist = {...pl, id: pl.id || 'inline'};
        return state.currentPlaylist;
      }
      try{
        const res = await fetch(`./playlists/${filename}`, {cache:'no-store'});
        if(!res.ok) throw new Error('playlist fetch failed');
        const data = await res.json();
        const id = filename.replace(/\.json$/,'');
        state.currentPlaylist = { id, __sourceFile: filename, __raw: data, ...data };
        return state.currentPlaylist;
      }catch(err){
        console.warn('Playlist load failed, falling back', err);
        const pl = pick(INLINED_PLAYLISTS);
        state.currentPlaylist = { ...pl, id: pl.id || 'inline', __sourceFile: null, __raw: pl };
        return state.currentPlaylist;
      }
    }

    function reshuffleQueue(){
      if(!state.currentPlaylist || !Array.isArray(state.currentPlaylist.items)) return;
      state.queue = shuffle(state.currentPlaylist.items.slice());
      state.index = -1;
      updateStatus(`Loaded ${state.queue.length} tracks from \u201C${state.currentPlaylist.title || state.currentPlaylist.id}\u201D`);
      $('#playlistName').textContent = state.currentPlaylist.title || state.currentPlaylist.id;
      // Update link to point to playlist-level link if provided
      const linkEl = document.getElementById('nowPlayingLink');
      const logoEl = document.getElementById('creatorLogo');
      const playlistLevelLink = state.currentPlaylist.link;
      if(playlistLevelLink && typeof playlistLevelLink === 'string'){
        linkEl.href = playlistLevelLink;
      }
      // Optional creator logo at playlist level: prefers explicit `logo`, falls back to `creatorLogo`
      const playlistLogo = state.currentPlaylist.logo || state.currentPlaylist.creatorLogo;
      if(typeof playlistLogo === 'string' && playlistLogo.trim()){
        // Hide until loaded to avoid initial flash before blend applies
        logoEl.style.opacity = '0';
        logoEl.onload = () => { logoEl.style.opacity = '1'; };
        logoEl.src = playlistLogo;
        logoEl.style.display = 'inline-block';
        logoEl.alt = state.currentPlaylist.title ? `${state.currentPlaylist.title} logo` : 'Creator logo';
      } else {
        logoEl.removeAttribute('src');
        logoEl.style.display = 'none';
        logoEl.alt = '';
      }
      // Optional logo blend mode (e.g., "multiply" to knock out whites)
      logoEl.classList.toggle('knock-white', (state.currentPlaylist.logoBlend || '').toLowerCase() === 'multiply');
    }

    async function pickRandomPlaylist(){
      // Prefer manifest when present
      if(state.manifest && Array.isArray(state.manifest.playlists) && state.manifest.playlists.length){
        const chosen = pick(state.manifest.playlists);
        await loadPlaylist(chosen);
      }else{
        // fall back to pre‑inlined
        await loadPlaylist(null);
      }
      reshuffleQueue();
    }

    function nextTrack(){
      if(!state.queue.length){ pickRandomPlaylist(); }
      state.index++;
      if(state.index >= state.queue.length){
        // Finished this playlist — pick a new random one
        pickRandomPlaylist().then(playCurrent);
        return;
      }
      playCurrent();
    }

    function prevTrack(){
      state.index = Math.max(0, state.index-1);
      playCurrent();
    }

    function clearRumbleTimers(){
      clearTimeout(state.rumbleTimer); state.rumbleTimer = null;
      if(state.rumblePoll){ clearInterval(state.rumblePoll); state.rumblePoll = null; }
      if(state.rumbleReadyTimeout){ clearTimeout(state.rumbleReadyTimeout); state.rumbleReadyTimeout = null; }
      if(state.rumbleVideoObserver){ try{ state.rumbleVideoObserver.disconnect(); }catch(_){} state.rumbleVideoObserver = null; }
      state.rumbleVideoEl = null;
      if(state.rumbleNudge){ try{ clearInterval(state.rumbleNudge); }catch(_){} state.rumbleNudge = null; }
    }

    function playCurrent(){
      clearRumbleTimers();
      const item = state.queue[state.index];
      if(!item || !item.url || typeof item.url !== 'string' || !item.url.trim()){
        console.warn('Skipping invalid playlist item (missing url)', item);
        nextTrack();
        return;
      }
      $('#trackTitle').textContent = item.title || 'Untitled';
      log('playCurrent: start', { index: state.index, of: state.queue.length, title: item.title, url: item.url });
      // Update the now playing link based on the current item, with fallbacks
      const nowLink = document.getElementById('nowPlayingLink');
      const logoEl = document.getElementById('creatorLogo');
      const candidateLink = item.link || item.page || item.url;
      try{
        const u = new URL(candidateLink);
        nowLink.href = u.toString();
      }catch(_){
        nowLink.removeAttribute('href');
      }
      // Item-level logo can override playlist-level logo if provided
      const itemLogo = item.logo || item.creatorLogo;
      if(typeof itemLogo === 'string' && itemLogo.trim()){
        // Hide until loaded to avoid initial flash before blend applies
        logoEl.style.opacity = '0';
        logoEl.onload = () => { logoEl.style.opacity = '1'; };
        logoEl.src = itemLogo;
        logoEl.style.display = 'inline-block';
        logoEl.alt = item.title ? `${item.title} logo` : 'Creator logo';
      } else {
        // If no item logo, keep what reshuffleQueue set (playlist-level), do nothing
      }
      // Item-level blend mode can override playlist-level blend mode if provided
      if(typeof item.logoBlend === 'string' && item.logoBlend.trim()){
        logoEl.classList.toggle('knock-white', item.logoBlend.toLowerCase() === 'multiply');
      }
      const embedInfo = toEmbed(item);
      const {provider} = embedInfo;
      const container = document.getElementById('playerContainer');

      // Destroy any existing YT player instance
      if(state.ytPlayer){ try{ state.ytPlayer.destroy(); }catch(e){} state.ytPlayer = null; }
      container.innerHTML = '';

      if(provider === 'youtube'){
        const holder = document.createElement('div'); holder.id = 'yt-player'; container.appendChild(holder);
        log('playCurrent: provider youtube');
        makeYouTubePlayer(holder.id, embedInfo.embed);
      }
      else if(provider === 'rumble'){
        // If a playlist- or item-level publisher code (e.g., "u12345") is provided, prefer Rumble's JS API
        const publisherCode = (item && (item.publisher || item.publisherCode)) || (state.currentPlaylist && (state.currentPlaylist.publisher || state.currentPlaylist.publisherCode));
        const useJsApi = !!(USE_RUMBLE_JS && typeof publisherCode === 'string' && /^u[0-9a-z]+$/i.test(publisherCode) && embedInfo.id);
        log('playCurrent: provider rumble', { id: embedInfo.id, publisherCode, useJsApi });
        if(useJsApi){
          const playerDivId = `rumble_${embedInfo.id}`;
          const holder = document.createElement('div'); holder.id = playerDivId; container.appendChild(holder);
          const jsUrl = `https://rumble.com/embedJS/${publisherCode}.${embedInfo.id}/`;
          log('Rumble JS: loading script', jsUrl);
          loadExternalScript(jsUrl)
            .then(() => {
              try{
                if(typeof window.Rumble === 'function'){
                  window.Rumble('play', { video: embedInfo.id, div: playerDivId, rel: 5, ia: 1, parameters: { autoplay: 2, controls: 1 } });
                  log('Rumble JS: play invoked', { video: embedInfo.id, div: playerDivId });
                  setTimeout(() => {
                    try{
                      const playersMap = window.Rumble && window.Rumble('players');
                      const keys = playersMap && typeof playersMap === 'object' ? Object.keys(playersMap) : [];
                      log('Rumble JS: players map keys', keys);
                    }catch(err){ warn('Rumble JS: players dump error', err); }
                  }, 1200);
                  // Discover native <video> element and attach 'ended' and 'loadedmetadata' listeners
                  try{
                    const containerEl = document.getElementById(playerDivId);
                    const tryWireVideo = () => {
                      const v = containerEl && containerEl.querySelector && containerEl.querySelector('video');
                      if(v && v !== state.rumbleVideoEl){
                        state.rumbleVideoEl = v;
                        log('Rumble Native: video found and wired');
                        // When metadata loads, we usually have a reliable duration; mark ready
                        v.addEventListener('loadedmetadata', () => {
                          if(Number.isFinite(v.duration)){
                            log('Rumble Native: loadedmetadata', { duration: v.duration });
                            // clearing ready-timeout happens when poll loop marks ready; this ensures duration is set
                          }
                        }, { once:true });
                        v.addEventListener('ended', () => {
                          log('Rumble Native: ended -> advancing');
                          clearRumbleTimers();
                          nextTrack();
                        }, { once:true });
                        // Try to nudge autoplay in case the player pauses on load
                        const nudgePlay = async () => { try{ if(v.paused) await v.play(); }catch(_){} };
                        try{ v.muted = true; }catch(_){ }
                        let nudgeCount = 0;
                        if(state.rumbleNudge){ try{ clearInterval(state.rumbleNudge); }catch(_){} }
                        state.rumbleNudge = setInterval(() => {
                          if(!document.body.contains(v)){ clearInterval(state.rumbleNudge); state.rumbleNudge = null; return; }
                          if(!v.paused){ clearInterval(state.rumbleNudge); state.rumbleNudge = null; return; }
                          if(nudgeCount++ > 10){ clearInterval(state.rumbleNudge); state.rumbleNudge = null; return; }
                          nudgePlay();
                        }, 500);
                      }
                    };
                    tryWireVideo();
                    if(state.rumbleVideoObserver){ try{ state.rumbleVideoObserver.disconnect(); }catch(_){} }
                    state.rumbleVideoObserver = new MutationObserver(() => tryWireVideo());
                    if(containerEl){ state.rumbleVideoObserver.observe(containerEl, { childList:true, subtree:true }); }
                  }catch(err){ warn('Rumble Native: observer setup error', err); }
                  // Poll the JS player for near-end to advance promptly
                  const pollMs = 500;
                  let sawPlayerReady = false;
                  let sampleTick = 0;
                  let lastProgressTs = Date.now();
                  state.rumblePoll = setInterval(() => {
                    try{
                      let player = null;
                      if(window.Rumble){
                        try{ player = window.Rumble('getPlayer', playerDivId); }catch(_){}
                        if(!player){
                          try{
                            const all = window.Rumble('players');
                            if(all && typeof all === 'object') player = all[playerDivId] || all[`rumble_${embedInfo.id}`] || all[embedInfo.id] || null;
                          }catch(_){ /* ignore */ }
                        }
                      }
                      let current = NaN, duration = NaN;
                      if(player){
                        const getC = player.getCurrentTime || player.currentTime || player.getPosition;
                        const getD = player.getDuration || player.duration;
                        current = Number(getC && getC.call(player));
                        duration = Number(getD && getD.call(player));
                      } else if(state.rumbleVideoEl){
                        current = Number(state.rumbleVideoEl.currentTime);
                        duration = Number(state.rumbleVideoEl.duration);
                      } else {
                        if(!sawPlayerReady) log('Rumble JS: player not ready yet');
                        return;
                      }
                      if(!sawPlayerReady && Number.isFinite(current) && Number.isFinite(duration)){
                        sawPlayerReady = true;
                        log('Rumble: playback ready', { durationSource: player ? 'js' : 'native', duration });
                        if(state.rumbleReadyTimeout){ clearTimeout(state.rumbleReadyTimeout); state.rumbleReadyTimeout = null; }
                        // Cancel the durationSec fallback timer once we have reliable timing from JS/native
                        if(state.rumbleTimer){ clearTimeout(state.rumbleTimer); state.rumbleTimer = null; }
                      }
                      if(Number.isFinite(duration) && duration > 0 && Number.isFinite(current)){
                        // track progress heartbeat
                        if(sampleTick === 0) lastProgressTs = Date.now();
                        // Heartbeat roughly every ~5s
                        sampleTick = (sampleTick + 1) % Math.max(1, Math.round(4000 / pollMs));
                        if(sampleTick === 0) log('Rumble: progress', { current, duration });
                        // aggressive near-end threshold + stall detection
                        const nearEndMargin = 6.0; // seconds
                        const stallMs = 2000; // if no progress for ~2s near end, advance
                        if(current >= duration - nearEndMargin || (current > 0 && (Date.now() - lastProgressTs) > stallMs && current >= duration - nearEndMargin - 2)){
                          clearRumbleTimers();
                          log('Rumble: near-end detected, advancing', { current, duration });
                          nextTrack();
                        }
                      }
                    }catch(err){ warn('Rumble JS: poll error', err); }
                  }, pollMs);
                  // If neither JS nor native becomes ready, fall back to iframe
                  state.rumbleReadyTimeout = setTimeout(() => {
                    warn('Rumble: ready timeout — falling back to iframe');
                    try{ if(state.rumblePoll){ clearInterval(state.rumblePoll); state.rumblePoll = null; } }catch(_){ }
                    try{ if(state.rumbleVideoObserver){ state.rumbleVideoObserver.disconnect(); state.rumbleVideoObserver = null; } }catch(_){ }
                    state.rumbleVideoEl = null;
                    container.innerHTML = '';
                    const iframe = document.createElement('iframe');
                    iframe.src = embedInfo.embed;
                    iframe.allow = 'autoplay; fullscreen; picture-in-picture; encrypted-media; clipboard-write';
                    iframe.referrerPolicy = 'origin-when-cross-origin';
                    container.appendChild(iframe);
                  }, 10000);
                }
              }catch(err){ console.warn('Rumble JS play error', err); }
            })
            .catch(err => { warn('Rumble JS load failed, falling back to iframe', err); });
          // Fallback auto-advance using provided duration
          const secs = parseDurationToSec(item.durationSec, 300, 30); const maxMs = secs * 1000;
          log('Rumble JS: setting fallback timeout', { secs });
          state.rumbleTimer = setTimeout(() => { updateStatus('Advancing (timeout)…'); log('Rumble JS: fallback timeout fired'); nextTrack(); }, maxMs);
        } else {
          // Default iframe embed
          const iframe = document.createElement('iframe');
          iframe.src = embedInfo.embed;
          iframe.allow = 'autoplay; fullscreen; picture-in-picture; encrypted-media; clipboard-write';
          iframe.referrerPolicy = 'origin-when-cross-origin';
          container.appendChild(iframe);
          const secs = parseDurationToSec(item.durationSec, 300, 30); const maxMs = secs * 1000; // default 5 min
          log('Rumble iframe: setting fallback timeout', { secs });
          state.rumbleTimer = setTimeout(() => { updateStatus('Advancing (timeout)…'); log('Rumble iframe: fallback timeout fired'); nextTrack(); }, maxMs);
        }
      }
      else if(provider === 'rumblePage'){
        log('playCurrent: provider rumblePage');
        // Try to show the full creator page in an iframe. If blocked by X-Frame-Options,
        // fall back to the embed URL after a short grace period.
        const iframe = document.createElement('iframe');
        iframe.src = embedInfo.page;
        iframe.allow = 'autoplay; fullscreen; picture-in-picture; encrypted-media; clipboard-write';
        iframe.referrerPolicy = 'origin-when-cross-origin';
        container.appendChild(iframe);

        let loaded = false;
        const graceMs = 2500; // try page for ~2.5s; if it fails to load, fall back
        const fallback = setTimeout(() => {
          if(loaded) return;
          updateStatus('Creator page blocked by browser — falling back to embed…');
          warn('Rumble page: blocked by browser, falling back to embed');
          iframe.src = embedInfo.fallbackEmbed || iframe.src; // swap to embed
        }, graceMs);
        iframe.addEventListener('load', () => { loaded = true; });

        const secs = parseDurationToSec(item.durationSec, 300, 30); const maxMs = secs * 1000; // time out to advance
        log('Rumble page: setting fallback timeout', { secs });
        state.rumbleTimer = setTimeout(() => { updateStatus('Advancing (timeout)…'); log('Rumble page: fallback timeout fired'); nextTrack(); }, maxMs);
      }
      else{
        warn('playCurrent: unknown provider, using link fallback', item && item.url);
        // Unknown provider: open as a plain link
        container.innerHTML = `<div class="yt-placeholder" style="display:grid;place-items:center;height:100%">`+
          `<a href="${item.url}" target="_blank" rel="noopener">Open track in new tab</a>`+
          `</div>`;
        const secs = parseDurationToSec(item.durationSec, 240, 20); const maxMs = secs * 1000;
        log('Unknown provider: setting fallback timeout', { secs });
        state.rumbleTimer = setTimeout(() => { log('Unknown provider: fallback timeout fired'); nextTrack(); }, maxMs);
      }

      updateStatus(`Playing ${state.index+1}/${state.queue.length}`);
    }

    function updateStatus(msg){ document.getElementById('status').textContent = msg; }

    // Download currently loaded playlist JSON
    function downloadCurrentPlaylist(){
      const pl = state.currentPlaylist;
      if(!pl){ return; }
      // Prefer original fetched data if available
      const payload = pl.__raw ? pl.__raw : {
        title: pl.title,
        logo: pl.logo,
        items: Array.isArray(pl.items) ? pl.items : []
      };
      const json = JSON.stringify(payload, null, 2);
      const blob = new Blob([json], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const fname = (pl.__sourceFile || (pl.id ? pl.id+'.json' : 'playlist.json')).replace(/[^a-z0-9._-]/gi,'_');
      a.href = url; a.download = fname; document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // ─────────────────────────────────────────────────────────────────────
    // YOUTUBE PLAYER CREATION + END HANDLING
    // ─────────────────────────────────────────────────────────────────────
    let youTubeApiReady = false;
    window.onYouTubeIframeAPIReady = function(){ youTubeApiReady = true; };

    function makeYouTubePlayer(elId, embedUrl){
      // Extract the videoId again for the Player API, safer than using full URL
      const idMatch = embedUrl.match(/embed\/([\w-]{6,})/);
      const videoId = idMatch ? idMatch[1] : null;
      if(!youTubeApiReady || !videoId){
        // Wait briefly then retry
        setTimeout(() => makeYouTubePlayer(elId, embedUrl), 200);
        return;
      }
      state.ytPlayer = new YT.Player(elId, {
        videoId,
        playerVars: { autoplay: 1, rel: 0, modestbranding: 1, playsinline: 1 },
        events: {
          onReady: e => { try{ e.target.playVideo(); }catch(_){} },
          onStateChange: e => {
            if(e.data === YT.PlayerState.ENDED){ log('YouTube: ended, advancing'); nextTrack(); }
          }
        }
      });
    }

    // ─────────────────────────────────────────────────────────────────────
    // GESTURE GATE + CONTROLS
    // ─────────────────────────────────────────────────────────────────────
    async function startApp(){
      if(state.started) return; state.started = true;
      document.getElementById('gestureGate').style.display = 'none';
      startGifLoop();
      startSprites();

      const list = await loadManifest();
      if(list && list.length){ updateStatus('Loaded manifest. Choosing a playlist…'); }
      await pickRandomPlaylist();
      nextTrack();
    }

    document.getElementById('startBtn').addEventListener('click', startApp, {once:true});
    document.getElementById('nextBtn').addEventListener('click', () => nextTrack());
    document.getElementById('prevBtn').addEventListener('click', () => prevTrack());
    document.getElementById('shuffleBtn').addEventListener('click', () => { reshuffleQueue(); nextTrack(); });
    document.getElementById('reloadBtn').addEventListener('click', async () => { await pickRandomPlaylist(); nextTrack(); });
    document.getElementById('downloadBtn').addEventListener('click', () => downloadCurrentPlaylist());

    // If the tab becomes hidden for a while, gently throttle ship spawns (optional)
    document.addEventListener('visibilitychange', () => {
      if(document.hidden){ /* could pause background spawns if desired */ }
    });

    // Optional: keyboard shortcuts
    window.addEventListener('keydown', e => {
      if(e.key === 'ArrowRight') nextTrack();
      if(e.key === 'ArrowLeft') prevTrack();
      if(e.key.toLowerCase() === 's') { reshuffleQueue(); nextTrack(); }
    });

    // ─────────────────────────────────────────────────────────────────────
    // DOCKING: shrink card to a tall, thin sidebar on left or right
    // ─────────────────────────────────────────────────────────────────────
    function isPhoneSized(){
      try{
        // Treat small viewports and most touch-first phones as "phone-sized"
        return (
          window.matchMedia('(max-width: 640px)').matches ||
          window.matchMedia('(pointer: coarse) and (max-width: 768px)').matches
        );
      }catch(_){
        return Math.min(window.innerWidth || 0, window.innerHeight || 0) <= 640;
      }
    }
    const cardEl = document.querySelector('.card');
    const dockBtn = document.getElementById('dockBtn');
    let dockSide = (typeof localStorage !== 'undefined' && localStorage.getItem('dockSide')) || 'right';
    let dockState = (typeof localStorage !== 'undefined' && localStorage.getItem('dockState')) || 'docked';
    // On phone/phone-sized viewports, prefer expanded view by default
    if(isPhoneSized()){
      dockState = 'expanded';
    }

    function updateDockUi(){
      const is = cardEl.classList.contains('docked');
      if(is){
        dockBtn.textContent = 'Expand';
        dockBtn.title = 'Expand to full size (right-click to switch side)';
      }else{
        dockBtn.textContent = '⇲ Dock';
        dockBtn.title = 'Dock: click to dock right, Shift+click to dock left';
      }
    }

    function dock(side){
      const s = side === 'left' ? 'left' : 'right';
      cardEl.classList.add('docked');
      cardEl.classList.toggle('dock-left', s === 'left');
      cardEl.classList.toggle('dock-right', s === 'right');
      dockSide = s;
      try{ localStorage.setItem('dockSide', dockSide); localStorage.setItem('dockState','docked'); }catch(_){}
      updateDockUi();
    }

    function undock(){
      cardEl.classList.remove('docked','dock-left','dock-right');
      try{ localStorage.setItem('dockState','expanded'); }catch(_){}
      updateDockUi();
    }

    dockBtn.addEventListener('click', (e) => {
      if(cardEl.classList.contains('docked')){ undock(); return; }
      const side = e.shiftKey ? 'left' : dockSide;
      dock(side);
    });

    dockBtn.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if(cardEl.classList.contains('docked')){
        dock(cardEl.classList.contains('dock-left') ? 'right' : 'left');
      }else{
        dock('left');
      }
    });

    // optional keyboard shortcut: 'd' to toggle dock
    window.addEventListener('keydown', e => {
      if(e.key.toLowerCase() === 'd'){
        if(cardEl.classList.contains('docked')) undock(); else dock(dockSide || 'right');
      }
    });

    // initialize state: default to docked unless user previously expanded
    if(dockState === 'docked'){
      dock(dockSide || 'right');
    } else {
      updateDockUi();
    }
  </script>
</body>
</html>
